name: LocalStack Lambda S3 CI/CD Pipeline

# Trigger Configuration
on:
  push:
    branches: [ main, develop, 'feature/**' ]
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - '.gitignore'
  pull_request:
    branches: [ main, develop ]
    paths-ignore:
      - '*.md'
      - 'docs/**'
  workflow_dispatch:
    inputs:
      skip_performance:
        description: 'Skip K6 performance tests'
        required: false
        default: false
        type: boolean
      node_version:
        description: 'Node.js version'
        required: false
        default: '20'
        type: choice
        options: ['18', '20', '22']

# Global environment variables
env:
  NODE_VERSION: ${{ github.event.inputs.node_version || '20' }}
  AWS_DEFAULT_REGION: us-east-1
  AWS_REGION: us-east-1
  AWS_ACCESS_KEY_ID: test
  AWS_SECRET_ACCESS_KEY: test
  BUCKET_NAME: test-bucket-${{ github.run_id }}
  LOCALSTACK_HOST: localhost
  ENDPOINT: http://localhost:4566
  API_URL: http://localhost:3000
  SKIP_PERFORMANCE: ${{ github.event.inputs.skip_performance == 'true' || github.event_name == 'pull_request' }}
  
# Concurrency control
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

# Security - minimal permissions
permissions:
  contents: write # Allow write to commit and push changes
  checks: write
  pull-requests: write
  actions: read # Allow reading workflow run status

jobs:
  # Job 1: Unit Tests
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install Dependencies
        run: npm ci --prefer-offline
        
      - name: Run Unit Tests with Coverage
        run: |
          npm run test:unit:coverage
        env:
          JEST_JUNIT_OUTPUT_DIR: ./reports/junit
          JEST_JUNIT_OUTPUT_NAME: unit-tests.xml
          
      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: unit-test-results
          path: |
            reports/coverage/
            reports/junit/
          retention-days: 30

  # Job 2: Integration Tests with LocalStack
  integration-tests:
    name: Integration & E2E Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: unit-tests
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install Dependencies
        run: npm ci --prefer-offline
        
      # Install K6 for performance tests
      - name: Setup K6
        uses: grafana/setup-k6-action@v1
        with:
          k6-version: latest
          
      # LocalStack Setup with optimized configuration
      - name: Start LocalStack
        uses: LocalStack/setup-localstack@v0.2.3
        with:
          image-tag: 'latest'
          install-awslocal: 'true'
          configuration: |
            SERVICES=lambda,s3,stepfunctions,dynamodb,iam
            DEBUG=1
            LS_LOG=warn
            LAMBDA_EXECUTOR=docker
            LAMBDA_REMOVE_CONTAINERS=0
            EAGER_SERVICE_LOADING=1
            HOSTNAME_EXTERNAL=localhost
            LOCALSTACK_HOST=localhost
            DOCKER_HOST=unix:///var/run/docker.sock
            LAMBDA_REMOTE_DOCKER=0
            LAMBDA_INIT_DELAYER=0
            LAMBDA_RUNTIME_ENVIRONMENT_TIMEOUT=60
            SYNCHRONOUS_KINESIS_EVENTS=1
            SYNCHRONOUS_SNS_EVENTS=1
            LAMBDA_DOCKER_NETWORK=host
            LAMBDA_DOCKER_FLAGS="-e LOCALSTACK_HOST=localhost -e ENDPOINT=http://localhost:4566"
            
      - name: Wait for LocalStack Services
        run: |
          echo "Waiting for LocalStack health check..."
          for i in {1..30}; do
            echo "Health check attempt $i of 30..."
            health_response=$(curl -s http://localhost:4566/_localstack/health || echo '{"error": "Connection failed"}')
            echo "$health_response" | jq '.'
            
            if echo "$health_response" | jq -e '.services.lambda == "available" and .services.s3 == "available"' >/dev/null; then
              echo "✅ LocalStack services are ready"
              break
            fi
            
            if [ $i -eq 30 ]; then
              echo "❌ LocalStack services failed to start"
              exit 1
            fi
            
            sleep 10
          done
          
          # Extra stabilization time
          echo "⏳ Allowing services to stabilize..."
          sleep 15
          
      - name: Verify LocalStack Services
        run: |
          echo "📊 LocalStack services status:"
          curl -s http://localhost:4566/_localstack/health | jq '.services'
          
          echo "🔌 Testing LocalStack connectivity..."
          curl -v http://localhost:4566/ || true
          
      - name: Create IAM Role for Lambda
        run: |
          echo "Creating IAM role for Lambda..."
          aws --endpoint-url=$ENDPOINT iam create-role \
            --role-name lambda-role \
            --assume-role-policy-document '{"Version": "2012-10-17", "Statement": [{"Effect": "Allow", "Principal": {"Service": "lambda.amazonaws.com"}, "Action": "sts:AssumeRole"}]}' \
            || echo "Role may already exist"
          
          aws --endpoint-url=$ENDPOINT iam create-policy \
            --policy-name s3-access-policy \
            --policy-document '{
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "s3:GetObject",
                    "s3:PutObject",
                    "s3:ListBucket"
                  ],
                  "Resource": [
                    "arn:aws:s3:::*",
                    "arn:aws:s3:::*/*"
                  ]
                }
              ]
            }' || echo "Policy may already exist"
            
          aws --endpoint-url=$ENDPOINT iam attach-role-policy \
            --role-name lambda-role \
            --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole \
            || echo "Policy may already be attached"
            
          aws --endpoint-url=$ENDPOINT iam attach-role-policy \
            --role-name lambda-role \
            --policy-arn arn:aws:iam::000000000000:policy/s3-access-policy \
            || echo "Policy may already be attached"

      - name: Deploy Test Infrastructure
        run: |
          echo "📦 Creating S3 bucket..."
          aws --endpoint-url=$ENDPOINT s3 mb s3://$BUCKET_NAME || echo "Bucket might already exist"
          
          echo "🛠️ Preparing Lambda deployment package..."
          npm install archiver
          rm -f function.zip || true
          
          # Package Lambda with dependencies
          if node scripts/package-lambda.js; then
            echo "✅ Lambda package created successfully"
          else
            echo "⚠️ Main packaging failed, using emergency packaging..."
            node scripts/emergency-package.js
          fi
          
          # Verify package contents
          echo "📦 Verifying Lambda package..."
          if unzip -l function.zip | grep -q "node_modules/lru-cache"; then
            echo "✅ Package contains required dependencies"
          else
            echo "❌ Missing dependencies in package"
            exit 1
          fi
          
          echo "🚀 Deploying Lambda function..."
          aws --endpoint-url=$ENDPOINT lambda create-function \
            --function-name test-lambda \
            --runtime nodejs20.x \
            --role arn:aws:iam::000000000000:role/lambda-role \
            --handler index.handler \
            --zip-file fileb://function.zip \
            --timeout 30 \
            --memory-size 256 \
            --environment "Variables={LOCALSTACK_HOST=localhost,ENDPOINT=http://localhost:4566,BUCKET=$BUCKET_NAME}" \
            || echo "Lambda may already exist"
          
          # Wait for Lambda to become active
          echo "⏳ Waiting for Lambda to become active..."
          for i in {1..12}; do
            status=$(aws --endpoint-url=$ENDPOINT lambda get-function --function-name test-lambda --query 'Configuration.State' --output text 2>/dev/null || echo "Unknown")
            echo "Lambda status: $status (attempt $i of 12)"
            if [ "$status" == "Active" ]; then
              echo "✅ Lambda is active and ready"
              break
            fi
            if [ $i -eq 12 ]; then
              echo "❌ Lambda failed to become active"
              exit 1
            fi
            sleep 10
          done
          
      - name: Start API Gateway Simulation
        run: |
          echo "🌐 Starting API Gateway simulation..."
          node api-gateway-sim.js > api-gateway.log 2>&1 &
          echo $! > api-gateway.pid
          
          echo "⏳ Waiting for API Gateway to be ready..."
          for i in {1..24}; do
            if curl -sf http://localhost:3000/health >/dev/null 2>&1; then
              echo "✅ API Gateway is ready"
              break
            fi
            if [ $i -eq 24 ]; then
              echo "❌ API Gateway failed to start"
              cat api-gateway.log
              exit 1
            fi
            echo "Waiting for API Gateway... (attempt $i)"
            sleep 5
          done
          
          # Additional stabilization
          sleep 10
          
      - name: Run Integration Tests
        run: |
          echo "🧪 Running integration tests..."
          
          # Create test file for upload/download tests
          echo "This is a test file for integration tests" > test.txt
          aws --endpoint-url=$ENDPOINT s3 cp test.txt s3://$BUCKET_NAME/test.txt
          
          # Test Lambda directly
          echo "🔍 Testing Lambda function directly..."
          aws --endpoint-url=$ENDPOINT lambda invoke \
            --function-name test-lambda \
            --payload '{"httpMethod":"GET", "queryStringParameters":{"filename":"test.txt"}}' \
            lambda-test-output.json
          cat lambda-test-output.json
          
          # Test API Gateway endpoints
          echo "🌐 Testing API Gateway endpoints..."
          curl -v http://localhost:3000/download?filename=test.txt
          
          # Run Jest integration tests if they exist
          if [ -d "tests/integration" ]; then
            echo "🧪 Running Jest integration tests..."
            LOCALSTACK_HOST=localhost \
            ENDPOINT=http://localhost:4566 \
            BUCKET=$BUCKET_NAME \
            npx jest \
              --runInBand \
              --verbose \
              --testMatch="**/tests/integration/**/*.integration.test.js" \
              --testTimeout=60000 \
              --forceExit \
              --detectOpenHandles
          fi
          
      - name: Run K6 Performance Tests
        if: env.SKIP_PERFORMANCE == 'false'
        run: |
          echo "⚡ Running K6 performance tests..."
          
          # Run POST tests
          echo "📤 Running POST performance tests..."
          k6 run \
            --out json=post-results.json \
            --env API_URL=http://localhost:3000 \
            --env AWS_ENDPOINT=http://localhost:4566 \
            --env AWS_REGION=us-east-1 \
            $GITHUB_WORKSPACE/k6/post-test.js
          
          # Run GET tests
          echo "📥 Running GET performance tests..."
          ls -la $GITHUB_WORKSPACE/k6 # Add this for debugging the next run if it fails
          k6 run \
            --out json=get-results.json \
            --env API_URL=http://localhost:3000 \
            --env AWS_ENDPOINT=http://localhost:4566 \
            --env AWS_REGION=us-east-1 \
            $GITHUB_WORKSPACE/k6/get-test.js
            
      - name: Generate Test Reports
        if: always()
        run: |
          echo "📊 Generating test reports..."
          npm run analyze || echo "Report generation failed but continuing..."
          
      - name: Collect LocalStack Logs
        if: always()
        run: |
          echo "📋 Collecting LocalStack logs..."
          localstack logs | tee localstack.log || true
          
          echo "📊 Final LocalStack health status:"
          curl -s http://localhost:4566/_localstack/health | jq '.' || true
          
          echo "📦 Created resources:"
          aws --endpoint-url=http://localhost:4566 s3 ls || true
          aws --endpoint-url=http://localhost:4566 lambda list-functions || true
          
          echo "📂 API Gateway logs:"
          cat api-gateway.log || true
          
      - name: Cleanup Background Processes
        if: always()
        run: |
          if [ -f api-gateway.pid ]; then
            kill $(cat api-gateway.pid) || true
            rm api-gateway.pid
          fi
          
      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ github.run_id }}
          path: |
            reports/
            *-results.json
            localstack.log
            api-gateway.log
            lambda-test-output.json
          retention-days: 30

  # Job 3: Security and Quality Check
  security-check:
    name: Security & Quality
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install Dependencies
        run: npm ci --prefer-offline
        
      - name: Security Audit
        run: |
          npm audit --audit-level=moderate --json > audit-results.json || true
          if [ -s audit-results.json ]; then
            echo "Security audit results:"
            cat audit-results.json | jq '.vulnerabilities // {}'
            HIGH_VULNS=$(cat audit-results.json | jq '.metadata.vulnerabilities.high // 0')
            CRITICAL_VULNS=$(cat audit-results.json | jq '.metadata.vulnerabilities.critical // 0')
            if [ "$HIGH_VULNS" -gt 0 ] || [ "$CRITICAL_VULNS" -gt 0 ]; then
              echo "❌ High or critical vulnerabilities found!"
              exit 1
            fi
            echo "✅ No high or critical vulnerabilities found"
          fi
          
      - name: Upload Security Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-results
          path: audit-results.json
          retention-days: 30

  # Job 4: Generate Summary Report
  summary:
    name: Generate Summary
    runs-on: ubuntu-latest
    timeout-minutes: 5
    # Depends on all preceding jobs, including the validation of the pushed workflow
    needs: [unit-tests, integration-tests, security-check, commit-and-push, validate-pushed-workflow]
    if: always() # Always run to provide a summary, regardless of upstream failures
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
          
      - name: Generate Summary Report
        run: |
          echo "## 🚀 LocalStack Lambda S3 Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Repository:** ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Run ID:** ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**LocalStack Bucket:** ${{ env.BUCKET_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Test Results" >> $GITHUB_STEP_SUMMARY
          echo "| Test Suite | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|------------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Unit Tests | ${{ needs.unit-tests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Integration Tests | ${{ needs.integration-tests.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Security Check | ${{ needs.security-check.result }} |" >> $GITHUB_STEP_SUMMARY
          # Add new job statuses, handle cases where they might be skipped
          echo "| Commit & Push | ${{ needs.commit-and-push.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Validate Pushed Workflow | ${{ needs.validate-pushed-workflow.result || 'skipped' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Overall success check should now include the validation job if it ran
          _ALL_JOBS_SUCCESS="true"
          if [[ "${{ needs.unit-tests.result }}" != "success" ]]; then _ALL_JOBS_SUCCESS="false"; fi
          if [[ "${{ needs.integration-tests.result }}" != "success" ]]; then _ALL_JOBS_SUCCESS="false"; fi
          if [[ "${{ needs.security-check.result }}" != "success" ]]; then _ALL_JOBS_SUCCESS="false"; fi
          # Only check commit-and-push if it was expected to run (i.e., not skipped)
          if [[ "${{ needs.commit-and-push.result }}" != "skipped" && "${{ needs.commit-and-push.result }}" != "success" ]]; then _ALL_JOBS_SUCCESS="false"; fi
          # Only check validate-pushed-workflow if it was expected to run
          if [[ "${{ needs.validate-pushed-workflow.result }}" != "skipped" && "${{ needs.validate-pushed-workflow.result }}" != "success" ]]; then _ALL_JOBS_SUCCESS="false"; fi

          if [[ "$_ALL_JOBS_SUCCESS" == "true" ]]; then
            echo "✅ **All tests passed successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The Lambda function was successfully deployed to LocalStack and tested with:" >> $GITHUB_STEP_SUMMARY
            echo "- Direct Lambda invocation" >> $GITHUB_STEP_SUMMARY
            echo "- API Gateway simulation" >> $GITHUB_STEP_SUMMARY
            echo "- S3 upload/download operations" >> $GITHUB_STEP_SUMMARY
            if [[ "${{ env.SKIP_PERFORMANCE }}" == "false" ]]; then
              echo "- K6 performance tests" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "❌ **Some tests failed.** Check the logs for details." >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `## 🧪 LocalStack Test Results
            
            **Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            **Commit:** \`${{ github.sha }}\`
            
            | Test Suite | Status |
            |------------|--------|
            | Unit Tests | ${{ needs.unit-tests.result }} |
            | Integration Tests | ${{ needs.integration-tests.result }} |
            | Security Check | ${{ needs.security-check.result }} |
            | Commit & Push | ${{ needs.commit-and-push.result || 'skipped' }} |
            | Validate Pushed Workflow | ${{ needs.validate-pushed-workflow.result || 'skipped' }} |
            
            ${ /* Check overall success, considering that commit/validate jobs might be skipped on PRs */ '' }
            ${
              (needs['unit-tests'].result === 'success' &&
               needs['integration-tests'].result === 'success' &&
               needs['security-check'].result === 'success' &&
               (needs['commit-and-push'].result === 'success' || needs['commit-and-push'].result === 'skipped') &&
               (needs['validate-pushed-workflow'].result === 'success' || needs['validate-pushed-workflow'].result === 'skipped')
              ) ? '✅ All checks passed!' : '❌ Some checks failed - review logs.'
            }
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Job 5: Commit and Push Changes
  commit-and-push:
    name: Commit and Push Changes
    runs-on: ubuntu-latest
    needs: [integration-tests, security-check] # Depends on successful completion of tests
    if: success() && github.event_name == 'push' # Only run on push events and if previous jobs succeeded
    outputs:
      committed_sha: ${{ steps.commit_push.outputs.commit_sha }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          # Fetch full history to allow proper commit and push
          fetch-depth: 0
          # Use a token with write permissions
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Dependencies (if needed for report generation or lockfile updates)
        run: npm ci --prefer-offline

      # Example: If reports are generated and should be committed
      - name: Download Test Artifacts (if reports are to be committed)
        uses: actions/download-artifact@v4
        with:
          name: test-results-${{ github.run_id }} # Ensure this matches the upload name
          path: artifacts/test-results # Download to a specific path

      - name: Configure Git
        run: |
          git config --global user.name "${{ github.actor }}"
          git config --global user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Commit and Push
        id: commit_push
        run: |
          # Add any specific files that might have changed or new reports
          # For example, if package-lock.json changed:
          git add package-lock.json
          # Add reports if they were downloaded and should be committed
          git add artifacts/test-results/* || echo "No new reports to add"
          git add reports/* || echo "No new reports to add"

          # Check for changes
          if git diff --staged --quiet; then
            echo "No changes to commit."
            # Output the current SHA if no new commit is made
            echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          else
            git commit -m "ci: Auto-commit updates from workflow run ${{ github.run_id }}"
            # Retry push with delay
            for i in {1..3}; do
              git push origin HEAD:${{ github.ref_name }} && break
              echo "Push attempt $i failed. Retrying in 10 seconds..."
              sleep 10
            done
            if ! git push origin HEAD:${{ github.ref_name }}; then
              echo "::error::Failed to push changes after multiple retries."
              exit 1
            fi
            echo "Pushed changes successfully."
            echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 6: Validate Pushed Workflow Run
  validate-pushed-workflow:
    name: Validate Pushed Workflow Run
    runs-on: ubuntu-latest
    needs: commit-and-push
    # Only run if a new commit was successfully pushed by the commit-and-push job.
    # This is determined by comparing the SHA output by commit-and-push
    # with the SHA that triggered this current workflow run.
    if: success() && github.event_name == 'push' && needs.commit-and-push.outputs.committed_sha != github.sha

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Validate Workflow Run Status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pushedSha = "${{ needs.commit-and-push.outputs.committed_sha }}";
            const currentRunId = ${{ github.run_id }};
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const branch = "${{ github.ref_name }}";

            console.log(`Pushed SHA: ${pushedSha}`);
            console.log(`Current Run ID: ${currentRunId}`);
            console.log(`Branch: ${branch}`);

            if (!pushedSha) {
              console.log("No new commit SHA provided by the previous job. Skipping validation.");
              return;
            }

            // Wait for a more generous period to allow the new workflow run to be initiated
            console.log("Waiting for 30 seconds before starting to poll for the new workflow run...");
            await new Promise(resolve => setTimeout(resolve, 30000)); // 30 seconds delay

            let attempts = 0;
            // Poll for up to 15 * 60s = 15 minutes (plus initial 30s delay)
            const maxAttempts = 15;
            const pollIntervalMs = 60000; // 60 seconds

            while (attempts < maxAttempts) {
              attempts++;
              console.log(`Attempt ${attempts}/${maxAttempts} to fetch workflow runs (poll interval: ${pollIntervalMs / 1000}s)...`);

              const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                branch,
                event: 'push', // Only consider push events
                per_page: 10, // Check recent runs
              });

              console.log(`Found ${runs.workflow_runs.length} runs on branch '${branch}'.`);

              // Find the workflow run that corresponds to the pushed commit
              // and is NOT the current workflow run.
              const targetRun = runs.workflow_runs.find(run => {
                console.log(`Checking run ID ${run.id} with SHA ${run.head_sha}`);
                return run.head_sha === pushedSha && run.id !== currentRunId;
              });

              if (targetRun) {
                console.log(`Found target workflow run: ID ${targetRun.id}, Status ${targetRun.status}, Conclusion ${targetRun.conclusion}`);

                if (targetRun.status === 'completed') {
                  if (targetRun.conclusion === 'success') {
                    console.log(`✅ Workflow run ${targetRun.id} for commit ${pushedSha} completed successfully.`);
                    return;
                  } else {
                    core.setFailed(`❌ Workflow run ${targetRun.id} for commit ${pushedSha} completed with conclusion: ${targetRun.conclusion}. URL: ${targetRun.html_url}`);
                    return;
                  }
                } else {
                  console.log(`Workflow run ${targetRun.id} is still in progress (Status: ${targetRun.status}). Waiting...`);
                }
              } else {
                console.log(`No matching workflow run found yet for SHA ${pushedSha} (that is not this run). Will retry.`);
              }

              if (attempts < maxAttempts) {
                console.log(`Next poll in ${pollIntervalMs / 1000} seconds...`);
                await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
              }
            }
            core.setFailed(`❌ Timed out after ${maxAttempts} attempts waiting for workflow run for commit ${pushedSha} to complete.`);
